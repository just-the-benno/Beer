<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="DHCPv4Option82Resolver_DHCPv4Option82Resolver_Caption" xml:space="preserve">
    <value>Custom Option82</value>
  </data>
  <data name="DHCPv4Option82Resolver_DHCPv4Option82Resolver_Content" xml:space="preserve">
    <value>This resolver can be used to match the given Option82 value. The value can be entered as byte sequence</value>
  </data>
  <data name="DHCPv4Option82Resolver_Value_Caption" xml:space="preserve">
    <value>Value</value>
  </data>
  <data name="DHCPv4Option82Resolver_Value_Content" xml:space="preserve">
    <value>Enter the exact value of the expected option 82  without 0x or any other characters.</value>
  </data>
  <data name="DHCPv4RelayAgentResolver_AgentAddresses_Caption" xml:space="preserve">
    <value>Relay Agent Addresses</value>
  </data>
  <data name="DHCPv4RelayAgentResolver_AgentAddresses_Content" xml:space="preserve">
    <value>You can list the IPv4 addresses of the relay agents that should be considered valid for this scopes. It's also possible to have just one address.</value>
  </data>
  <data name="DHCPv4RelayAgentResolver_DHCPv4RelayAgentResolver_Caption" xml:space="preserve">
    <value>Relay Agents</value>
    <comment> </comment>
  </data>
  <data name="DHCPv4RelayAgentResolver_DHCPv4RelayAgentResolver_Content" xml:space="preserve">
    <value>This resolver checks if the "Relay Agent Address" field has the value of one of the listed relay agents</value>
  </data>
  <data name="DHCPv4RelayAgentSubnetResolver_DHCPv4RelayAgentSubnetResolver_Caption" xml:space="preserve">
    <value>Relay Agent Subnet </value>
  </data>
  <data name="DHCPv4RelayAgentSubnetResolver_DHCPv4RelayAgentSubnetResolver_Content" xml:space="preserve">
    <value>This resolver checks if the "Relay Agent Address" field is part of the listed subnet.</value>
  </data>
  <data name="DHCPv4RelayAgentSubnetResolver_Mask_Caption" xml:space="preserve">
    <value>subnet mask</value>
  </data>
  <data name="DHCPv4RelayAgentSubnetResolver_Mask_Content" xml:space="preserve">
    <value>The subnet mask (0... 32) of the corresponding subnet</value>
  </data>
  <data name="DHCPv4RelayAgentSubnetResolver_NetworkAddress_Caption" xml:space="preserve">
    <value>Network Address</value>
  </data>
  <data name="DHCPv4RelayAgentSubnetResolver_NetworkAddress_Content" xml:space="preserve">
    <value>This is the subnet address that made the subnet. For instance, 192.168.100.0/24 (without the subnet mask)</value>
  </data>
  <data name="DHCPv4SimpleCiscoSGSeriesResolver_DeviceMacAddress_Caption" xml:space="preserve">
    <value>Device MAC Address</value>
  </data>
  <data name="DHCPv4SimpleCiscoSGSeriesResolver_DeviceMacAddress_Content" xml:space="preserve">
    <value>The MAC Address of the SG switch serving as DHCP snooping agent. This device adds option 82. Not the MAC Address of the connected device</value>
  </data>
  <data name="DHCPv4SimpleCiscoSGSeriesResolver_DHCPv4SimpleCiscoSGSeriesResolver_Caption" xml:space="preserve">
    <value>Cisco SG Switch</value>
  </data>
  <data name="DHCPv4SimpleCiscoSGSeriesResolver_DHCPv4SimpleCiscoSGSeriesResolver_Content" xml:space="preserve">
    <value>This resolver can be used if a Cisco SG Switch like the SG300 and SG350 has the DHCP snooping activated and inserted option 82. The association is based on the VLAN ID and port of the customer/user and the device's MAC address.</value>
  </data>
  <data name="DHCPv4SimpleCiscoSGSeriesResolver_PortNumber_Caption" xml:space="preserve">
    <value>Port</value>
  </data>
  <data name="DHCPv4SimpleCiscoSGSeriesResolver_PortNumber_Content" xml:space="preserve">
    <value>The port number (1 ... 48) of the port, where the customer/user is connected.</value>
  </data>
  <data name="DHCPv4SimpleCiscoSGSeriesResolver_VlanNumber_Caption" xml:space="preserve">
    <value>VLAN ID</value>
  </data>
  <data name="DHCPv4SimpleCiscoSGSeriesResolver_VlanNumber_Content" xml:space="preserve">
    <value>Is this the VLAN ID of the customer/user that should be valid for this resolver. You can enter any ID between 1 and 4094.</value>
  </data>
  <data name="DHCPv4SimpleZyxelIESResolver_DeviceMacAddress_Caption" xml:space="preserve">
    <value>Device MAC Address</value>
  </data>
  <data name="DHCPv4SimpleZyxelIESResolver_DeviceMacAddress_Content" xml:space="preserve">
    <value>Enter the mac address of the Zyxel devices without 0x or any other characters. View the system information page (or command) to receive the device mac address.</value>
  </data>
  <data name="DHCPv4SimpleZyxelIESResolver_DHCPv4SimpleZyxelIESResolver_Caption" xml:space="preserve">
    <value>Zyxel IES MSAN</value>
  </data>
  <data name="DHCPv4SimpleZyxelIESResolver_DHCPv4SimpleZyxelIESResolver_Content" xml:space="preserve">
    <value>This resolver can be used if a Zyxel IES5x.. or IES6x is used as a "Layer2 relay agent". This resolver assumes that the variable "%slotid/%pid" is used for opt82-circuit-id option and %dmac3 is used for the opt82-remote-id option. See the DaAPI documentation for more detailed explanation and configuration example for the Zyxel IES series.</value>
  </data>
  <data name="DHCPv4SimpleZyxelIESResolver_LinecardNumber_Caption" xml:space="preserve">
    <value>Linecard</value>
  </data>
  <data name="DHCPv4SimpleZyxelIESResolver_LinecardNumber_Content" xml:space="preserve">
    <value>The number of the slot (1 to 10) the port on the line card is connected to the device.</value>
  </data>
  <data name="DHCPv4SimpleZyxelIESResolver_PortNumber_Caption" xml:space="preserve">
    <value>Port</value>
  </data>
  <data name="DHCPv4SimpleZyxelIESResolver_PortNumber_Content" xml:space="preserve">
    <value>The port number (1 ... 80) of the port, where the customer/user is connected.</value>
  </data>
  <data name="DHCPv6ClientDUIDResolver_ClientDuid_Caption" xml:space="preserve">
    <value>Client DUID</value>
  </data>
  <data name="DHCPv6ClientDUIDResolver_ClientDuid_Content" xml:space="preserve">
    <value>The byte value - without 0x or any other signs (-,: etc.) of the DUID. It needs to start with the DUID identifier like 0003 for Link Layer Address</value>
  </data>
  <data name="DHCPv6ClientDUIDResolver_DHCPv6ClientDUIDResolver_Caption" xml:space="preserve">
    <value>Client DUID</value>
  </data>
  <data name="DHCPv6ClientDUIDResolver_DHCPv6ClientDUIDResolver_Content" xml:space="preserve">
    <value>Checks if the message is originated by a specified client based on its DUID. This can be used to assign the same client the same address.</value>
  </data>
  <data name="DHCPv6MilegateResolver_DHCPv6MilegateResolver_Caption" xml:space="preserve">
    <value>DHCPv6 Milegate resolver</value>
  </data>
  <data name="DHCPv6MilegateResolver_DHCPv6MilegateResolver_Content" xml:space="preserve">
    <value>This resolver can be used for Milegates devices from the manufactures Keymile. This device allows you to enter any text as a value that will be inserted in the remote-id option of an incoming relay forward message. This resolver checks if an incoming message has precisely this value.</value>
  </data>
  <data name="DHCPv6MilegateResolver_Index_Caption" xml:space="preserve">
    <value>relay agent index</value>
  </data>
  <data name="DHCPv6MilegateResolver_Index_Content" xml:space="preserve">
    <value>This property specified that the match needs at the selected relay agent. The relay agent with index zero is the nearest to the client. A relay agent with the index one would be the second relay agent passed on the way from the client to the server.</value>
  </data>
  <data name="DHCPv6MilegateResolver_IsCaseSenstiveMatch_Caption" xml:space="preserve">
    <value>Is case-senstive match</value>
  </data>
  <data name="DHCPv6MilegateResolver_IsCaseSenstiveMatch_Content" xml:space="preserve">
    <value>The option value is interpreted as text. If this property is activated an option value of "eth1/001 INTERface 1" won't match the value of "eth1/001 interface 1". If this property is deactivated, the resolvers will match.</value>
  </data>
  <data name="DHCPv6MilegateResolver_Value_Caption" xml:space="preserve">
    <value>Value</value>
  </data>
  <data name="DHCPv6MilegateResolver_Value_Content" xml:space="preserve">
    <value>This represents the value of the inserted option. Usually, it is like eth1/001 interface 1, but any input can be chosen</value>
  </data>
  <data name="DHCPv6PeerAddressResolver_DHCPv6PeerAddressResolver_Caption" xml:space="preserve">
    <value>Peer address</value>
  </data>
  <data name="DHCPv6PeerAddressResolver_DHCPv6PeerAddressResolver_Content" xml:space="preserve">
    <value>This resolver checks if the peer address in any relay forward messages has the specified address.</value>
  </data>
  <data name="DHCPv6PeerAddressResolver_IsUnique_Caption" xml:space="preserve">
    <value>Is unique</value>
  </data>
  <data name="DHCPv6PeerAddressResolver_IsUnique_Content" xml:space="preserve">
    <value>If this property is activated, it will be assumed that the peer address is unique. In conjunction with the option of reusing addresses, this leads to a reassign of the same address even when two different clients. If this property is deactivated, the address is not treated as unique.</value>
  </data>
  <data name="DHCPv6PeerAddressResolver_PeerAddress_Caption" xml:space="preserve">
    <value>Peer address</value>
  </data>
  <data name="DHCPv6PeerAddressResolver_PeerAddress_Content" xml:space="preserve">
    <value>The peer address (in most cases a link local address) that should be a match of this resolvers. Can be any valid IPv6 address.</value>
  </data>
  <data name="DHCPv6PseudoResolver_DHCPv6PseudoResolver_Caption" xml:space="preserve">
    <value>pseudo resolver</value>
  </data>
  <data name="DHCPv6PseudoResolver_DHCPv6PseudoResolver_Content" xml:space="preserve">
    <value>The pseudo resolver is a match for every message and should be used to group scopes with common properties. Unlike other DHCP servers, DaAPI doesn't allow to have global properties. Instead, you can create a root scope with the pseudo resolvers. Each child scope derivate from this root scope will inheritance the root properties, and hence, the pseudo resolver resolves to true for each packet, you can set a more specific resolver for the child scopes. To learn more about how to create scope tress referrers to the DaAPI documentation.</value>
  </data>
  <data name="DHCPv6RelayAgentResolver_DHCPv6RelayAgentResolver_Caption" xml:space="preserve">
    <value>Relay agent resolver</value>
  </data>
  <data name="DHCPv6RelayAgentResolver_DHCPv6RelayAgentResolver_Content" xml:space="preserve">
    <value>The relay agent address resolver checks if the source address of a relay agent is precisely this address</value>
  </data>
  <data name="DHCPv6RelayAgentResolver_RelayAgentAddress_Caption" xml:space="preserve">
    <value>Relay agent address</value>
  </data>
  <data name="DHCPv6RelayAgentResolver_RelayAgentAddress_Content" xml:space="preserve">
    <value>The address of the expected relay agent</value>
  </data>
  <data name="DHCPv6RelayAgentSubnetResolver_DHCPv6RelayAgentSubnetResolver_Caption" xml:space="preserve">
    <value>Relay agent subnet resolver</value>
  </data>
  <data name="DHCPv6RelayAgentSubnetResolver_DHCPv6RelayAgentSubnetResolver_Content" xml:space="preserve">
    <value>This resolves checks if the relay agent source address is from the specified subnet.</value>
  </data>
  <data name="DHCPv6RelayAgentSubnetResolver_NetworkAddress_Caption" xml:space="preserve">
    <value>network address</value>
  </data>
  <data name="DHCPv6RelayAgentSubnetResolver_NetworkAddress_Content" xml:space="preserve">
    <value>The subnet address of the desired relay agent</value>
  </data>
  <data name="DHCPv6RelayAgentSubnetResolver_SubnetMask_Caption" xml:space="preserve">
    <value>subnet mask</value>
  </data>
  <data name="DHCPv6RelayAgentSubnetResolver_SubnetMask_Content" xml:space="preserve">
    <value>The subnet mask (0...128) of the corresponding subnet</value>
  </data>
  <data name="DHCPv6RemoteIdentifierEnterpriseNumberResolver_DHCPv6RemoteIdentifierEnterpriseNumberResolver_Caption" xml:space="preserve">
    <value>DHCPv6 Remote identifier Enterprise Number Resolver</value>
  </data>
  <data name="DHCPv6RemoteIdentifierEnterpriseNumberResolver_DHCPv6RemoteIdentifierEnterpriseNumberResolver_Content" xml:space="preserve">
    <value>Checks if the remote identifier option as the specified enterprise number. A simple use case for this resolver is to check if a relay agent is "manufactured" by a specific organization. For more details, referrer to the DaAPI documentation.</value>
  </data>
  <data name="DHCPv6RemoteIdentifierEnterpriseNumberResolver_EnterpriseNumber_Caption" xml:space="preserve">
    <value>Enterprise Number</value>
  </data>
  <data name="DHCPv6RemoteIdentifierEnterpriseNumberResolver_EnterpriseNumber_Content" xml:space="preserve">
    <value>Enter the number assigned by the IANA for the manufacturing company.</value>
  </data>
  <data name="DHCPv6RemoteIdentifierEnterpriseNumberResolver_RelayAgentIndex_Caption" xml:space="preserve">
    <value>Relay agent index</value>
  </data>
  <data name="DHCPv6RemoteIdentifierEnterpriseNumberResolver_RelayAgentIndex_Content" xml:space="preserve">
    <value>This property, if enabled, specified that the match needs at the selected relay agent. The relay agent with index zero is the nearest to the client. If this property is not enabled, the match can occur by any relay agent.</value>
  </data>
  <data name="DHCPv6SimpleZyxelIESResolver_DeviceMacAddress_Caption" xml:space="preserve">
    <value>Device MAC address</value>
  </data>
  <data name="DHCPv6SimpleZyxelIESResolver_DeviceMacAddress_Content" xml:space="preserve">
    <value>Enter the mac address of the Zyxel devices without 0x or any other characters. View the system information page (or command) to receive the device mac address.</value>
  </data>
  <data name="DHCPv6SimpleZyxelIESResolver_DHCPv6SimpleZyxelIESResolver_Caption" xml:space="preserve">
    <value>Simple Zyxel IES</value>
  </data>
  <data name="DHCPv6SimpleZyxelIESResolver_DHCPv6SimpleZyxelIESResolver_Content" xml:space="preserve">
    <value>This resolver can be used if a Zyxel IES5x.. or IES6x is used as a "Layer2 relay agent" (LDRA). This resolver assumes that the variable "%slotid/%portid" is used for the interface option and %dmac3 is used for the remote-id option. See the DaAPI documentation for more detailed explanation and configuration example for the Zyxel IES series.</value>
  </data>
  <data name="DHCPv6SimpleZyxelIESResolver_Index_Caption" xml:space="preserve">
    <value>relay agent index</value>
  </data>
  <data name="DHCPv6SimpleZyxelIESResolver_Index_Content" xml:space="preserve">
    <value>This property specified that the match needs at the selected relay agent. The relay agent with index zero is the nearest to the client. A relay agent with the index one would be the second relay agent passed on the way from the client to the server.</value>
  </data>
  <data name="DHCPv6SimpleZyxelIESResolver_PortId_Caption" xml:space="preserve">
    <value>Port number</value>
  </data>
  <data name="DHCPv6SimpleZyxelIESResolver_PortId_Content" xml:space="preserve">
    <value>The number of the port the device is connected</value>
  </data>
  <data name="DHCPv6SimpleZyxelIESResolver_SlotId_Caption" xml:space="preserve">
    <value>Slot number</value>
  </data>
  <data name="DHCPv6SimpleZyxelIESResolver_SlotId_Content" xml:space="preserve">
    <value>The number of the slot (1 to 10) the port on the line card is connected to the device.</value>
  </data>
  <data name="PropertyCaption" xml:space="preserve">
    <value>Resolver Property</value>
  </data>
  <data name="ResolverCaption" xml:space="preserve">
    <value>Resolver</value>
  </data>
</root>