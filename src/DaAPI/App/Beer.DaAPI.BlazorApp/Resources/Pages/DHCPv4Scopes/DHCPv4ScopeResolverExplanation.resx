<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="DHCPv4Option82Resolver_DHCPv4Option82Resolver_Caption" xml:space="preserve">
    <value>Custom Option82</value>
  </data>
  <data name="DHCPv4Option82Resolver_DHCPv4Option82Resolver_Content" xml:space="preserve">
    <value>This resolver can be used to match the given Option82 value. The value can be entered as byte sequence</value>
  </data>
  <data name="DHCPv4Option82Resolver_Value_Caption" xml:space="preserve">
    <value>Value</value>
  </data>
  <data name="DHCPv4Option82Resolver_Value_Content" xml:space="preserve">
    <value>Enter the exact value of the expected option 82  without 0x or any other characters.</value>
  </data>
  <data name="DHCPv4RelayAgentResolver_AgentAddresses_Caption" xml:space="preserve">
    <value>Relay Agent Addresses</value>
  </data>
  <data name="DHCPv4RelayAgentResolver_AgentAddresses_Content" xml:space="preserve">
    <value>You can list the IPv4 addresses of the relay agents that should be considered valid for this scopes. It's also possible to have just one address.</value>
  </data>
  <data name="DHCPv4RelayAgentResolver_DHCPv4RelayAgentResolver_Caption" xml:space="preserve">
    <value>Relay Agents</value>
  </data>
  <data name="DHCPv4RelayAgentResolver_DHCPv4RelayAgentResolver_Content" xml:space="preserve">
    <value>This resolver checks if the "Relay Agent Address" field has the value of one of the listed relay agents</value>
  </data>
  <data name="DHCPv4RelayAgentSubnetResolver_DHCPv4RelayAgentSubnetResolver_Caption" xml:space="preserve">
    <value>Relay Agent Subnet </value>
  </data>
  <data name="DHCPv4RelayAgentSubnetResolver_DHCPv4RelayAgentSubnetResolver_Content" xml:space="preserve">
    <value>This resolver checks if the "Relay Agent Address" field is part of the listed subnet.</value>
  </data>
  <data name="DHCPv4RelayAgentSubnetResolver_Mask_Caption" xml:space="preserve">
    <value>subnet mask</value>
  </data>
  <data name="DHCPv4RelayAgentSubnetResolver_Mask_Content" xml:space="preserve">
    <value>The subnet mask (0... 32) of the corresponding subnet</value>
  </data>
  <data name="DHCPv4RelayAgentSubnetResolver_NetworkAddress_Caption" xml:space="preserve">
    <value>Network Address</value>
  </data>
  <data name="DHCPv4RelayAgentSubnetResolver_NetworkAddress_Content" xml:space="preserve">
    <value>This is the subnet address that made the subnet. For instance, 192.168.100.0/24 (without the subnet mask)</value>
  </data>
  <data name="DHCPv4SimpleCiscoSGSeriesResolver_DeviceMacAddress_Caption" xml:space="preserve">
    <value>Device MAC Address</value>
  </data>
  <data name="DHCPv4SimpleCiscoSGSeriesResolver_DeviceMacAddress_Content" xml:space="preserve">
    <value>The MAC Address of the SG switch serving as DHCP snooping agent. This device adds option 82. Not the MAC Address of the connected device</value>
  </data>
  <data name="DHCPv4SimpleCiscoSGSeriesResolver_DHCPv4SimpleCiscoSGSeriesResolver_Caption" xml:space="preserve">
    <value>Cisco SG Switch</value>
  </data>
  <data name="DHCPv4SimpleCiscoSGSeriesResolver_DHCPv4SimpleCiscoSGSeriesResolver_Content" xml:space="preserve">
    <value>This resolver can be used if a Cisco SG Switch like the SG300 and SG350 has the DHCP snooping activated and inserted option 82. The association is based on the VLAN ID and port of the customer/user and the device's MAC address.</value>
  </data>
  <data name="DHCPv4SimpleCiscoSGSeriesResolver_PortNumber_Caption" xml:space="preserve">
    <value>Port</value>
  </data>
  <data name="DHCPv4SimpleCiscoSGSeriesResolver_PortNumber_Content" xml:space="preserve">
    <value>The port number (1 ... 48) of the port, where the customer/user is connected.</value>
  </data>
  <data name="DHCPv4SimpleCiscoSGSeriesResolver_VlanNumber_Caption" xml:space="preserve">
    <value>VLAN ID</value>
  </data>
  <data name="DHCPv4SimpleCiscoSGSeriesResolver_VlanNumber_Content" xml:space="preserve">
    <value>Is this the VLAN ID of the customer/user that should be valid for this resolver. You can enter any ID between 1 and 4094.</value>
  </data>
  <data name="DHCPv4SimpleZyxelIESResolver_DeviceMacAddress_Caption" xml:space="preserve">
    <value>Device MAC Address</value>
  </data>
  <data name="DHCPv4SimpleZyxelIESResolver_DeviceMacAddress_Content" xml:space="preserve">
    <value>Enter the mac address of the Zyxel devices without 0x or any other characters. View the system information page (or command) to receive the device mac address.</value>
  </data>
  <data name="DHCPv4SimpleZyxelIESResolver_DHCPv4SimpleZyxelIESResolver_Caption" xml:space="preserve">
    <value>Zyxel IES MSAN</value>
  </data>
  <data name="DHCPv4SimpleZyxelIESResolver_DHCPv4SimpleZyxelIESResolver_Content" xml:space="preserve">
    <value>This resolver can be used if a Zyxel IES5x.. or IES6x is used as a "Layer2 relay agent". This resolver assumes that the variable "%slotid/%pid" is used for opt82-circuit-id option and %dmac3 is used for the opt82-remote-id option. See the DaAPI documentation for more detailed explanation and configuration example for the Zyxel IES series.</value>
  </data>
  <data name="DHCPv4SimpleZyxelIESResolver_LinecardNumber_Caption" xml:space="preserve">
    <value>Linecard</value>
  </data>
  <data name="DHCPv4SimpleZyxelIESResolver_LinecardNumber_Content" xml:space="preserve">
    <value>The number of the slot (1 to 10) the port on the line card is connected to the device.</value>
  </data>
  <data name="DHCPv4SimpleZyxelIESResolver_PortNumber_Caption" xml:space="preserve">
    <value>Port</value>
  </data>
  <data name="DHCPv4SimpleZyxelIESResolver_PortNumber_Content" xml:space="preserve">
    <value>The port number (1 ... 80) of the port, where the customer/user is connected.</value>
  </data>
  <data name="PropertyCaption" xml:space="preserve">
    <value>Resolver Property</value>
  </data>
  <data name="ResolverCaption" xml:space="preserve">
    <value>Resolver</value>
  </data>
</root>